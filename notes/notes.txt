1.2
"Pure functions are restricted in that they cannot have side effects or change behavior over time. "

HOF definition:
    A function that manipulates other functions as data is called a higher order function (HOF).
    For instance, a HOF can be a function that takes functions as arguments, returns a function
    as its value, or both.

difference defining functions with "def" vs. lambda expression:
  - "def" is a statement, evaluation has a side effect > generating function binding in current environment
  - lambda is an expression which won't usually change environemnt
    exception: lambda expression is assigned to a variable

pattern for designing recursive functions:
 - start with a base case, conditional statement for function inputs that are >>>simplest<<< 
   to process
 - base case is followed by one or more recursive calls. recursive calls have one goal:
   >>>simplifying the original problem<<<.
   recursive functions express computation by simplifying problems incremendially
     
leap of faith:
 - treating a recursive call as a function abstraction
 
mutual recursion:
 - a recursive procedure is divided by two functions calling each other  


tipps from lab for recursive functions:

  1. Always start with the base case. The base case handles the simplest argument 
     your function would have to handle. The answer is extremely simple, and often 
     follows from the definition of the problem.

  2. Make a recursive call with a slightly simpler argument. This is called the 
     "leap of faith" - your simpler argument should simplify the problem, and you 
     should assume that the recursive call for this simpler problem will just work. 
     As you do more problems, you'll get better at this step.

  3. Use the recursive call. Remember that the recursive call solves a simpler version 
     of the problem. Now ask yourself how you can use this result to solve the original 
     problem.

As a general rule of thumb, whenever you need to try multiple possibilities at the same time, 
you should consider using tree recursion.

tail recursion
..............
  - http://de.wikipedia.org/wiki/Endrekursion
  - "...wenn der rekursive Funktionsaufruf die letzte Aktion zur Berechnung von f ist"

  Example
  .......

  no tail recursion:
  
  def len_rlist(s):         # A sequence is: 
    """The length of rlist S."""
    if s == empty_rlist:    # Empty or...
        return 0
    else:
        return 1 + len_rlist(rest(s))
                            # A first element and
                            # the rest of the list 

    returned length is accumulated via summing up all the "1" returned.

    tail recursive version:

    def len_rlist(s):
        def len(sofar, s):
        """Return SOFAR + the length of rlist S."""
            if s == empty_rlist:
                return sofar
            else:
                return len(sofar + 1, rest(s))
        len(0, s)

     "sofar" is directly returned, no extra accumulation required. temporary
     values are stored as argument to helper function "len".


     from tail recursion it is easy to an iterative solution:

     def len_rlist(s):
        sofar = 0
        while s != empty_rlist:
            sofar, s = sofar+1, rest(s)
        return sofar

    from recursion to iteration: http://www.refactoring.com/catalog/replaceRecursionWithIteration.html

lessons learned recursion (German)
..................................

- haeufig liegen base case bedingung um "0", eine summation/ berechnung bis zu einem spitzenwert
  wird versucht umzubauen zu einer differenzbildung die gegen "0" geht
- per rekursivem aufruf geaenderte parameter ( zb. def f(sum):  aufruf: f(sum-1) sind im frame
  der aufgerufenen funktion mit neuem geaenderten wert lokal vorhanden. von hier aus kann weiter
  runtergebrochen werden.
- summation: wenn nicht gegen "0" gearbeitet werden kann, muss trotzdem irgendwie ein abbruch
  wert (z.b. max_sum) in die rekusive-funktion propagiert werden. das macht man am besten mit
  einer  hilfsfunktion, die als zusaetzliches, sich nicht aenderndes argument den orignalwert
  max_sum mitfuehrt. siehe discussion/discussion3.py has_sum2() und sum_range() 
- bei sprachen mit lexical scoping kann die innere hilfsfunktion problemlos auf die argumente
  der parent-function zugreifen, siehe sum_range()   
- tree-recursion: wenn es um wahrheitspruefung (True/ False) geht, dann werden die verschiedenen
  suchzweige mit "OR" verknuepft. ein einziges "TRUE" in einer der rekursiven funktionsaufrufe
  wird bis nach oben propagiert und gibt als gesamtergebnis auch ein TRUE 

Data Abstraction
----------------
Data abstraction is a methodology that enables us to isolate how a compound data object
is used from the details of how it is constructed.


Abstract Data Types
...................
ADTs are conceptual: a given programming language may or may not
have constructs specifically designed for ADT definition, but pro-
grammers can choose to organize their programs as collections of
ADTs in any case.

---------------------------------
A common convention is to use a single underscore character for the name in the for header 
if the name is unused in the suite:

>>> for _ in range(3):
        print('Go Bears!')

Go Bears!
Go Bears!
Go Bears!

This underscore is just another name in the environment as far as the interpreter is concerned, 
but has a conventional meaning among programmers that indicates the name will not appear in 
any expressions.
--------------------------------------

map/reduce
----------
- general computational patterns of mapping, filtering, and accumulation


example of a dispatch function
..............................
>>> def dictionary():
        """Return a functional implementation of a dictionary."""
        records = []
        def getitem(key):
            for k, v in records:
                if k == key:
                    return v
        def setitem(key, value):
            for item in records:
                if item[0] == key:
                    item[1] = value
                    return
            records.append([key, value])
        def dispatch(message, key=None, value=None):
            if message == 'getitem':
                return getitem(key)
            elif message == 'setitem':
                setitem(key, value)
            elif message == 'keys':
                return tuple(k for k, _ in records)
            elif message == 'values':
                return tuple(v for _, v in records)
        return dispatch

using the function:
>>> d = dictionary()
>>> d('setitem', 3, 9)
>>> d('setitem', 4, 16)
>>> d('getitem', 3)
9
>>> d('getitem', 4)
16
>>> d('keys')
(3, 4)
>>> d('values')
(9, 16)

constrained based system
........................

- is a programming paradigm (http://en.wikipedia.org/wiki/Constraint_programming)
- calculation possible in multiple directions (not just only one as with using an equation)
- modelling the constraint with simple blocks like constants, adder, multiplier, (user) input
- changing the input changes also the network which results to a different value at on other input
- see example with converting celius to fahrenheit and back



TODO clearify "proof by induction"

running doc tests:
python3 -m doctest -v hog.py


noetherian induction:
a relation on values is well founded if there are no infinite decending chaines.

"If you start at some value and keep stepping to smaller values (according to the relation)
then you must always get to a minimal value after finite steps."

add:
basic recursion rules + example


swap:

score + margin = opponent score : return 0

harmful

opponent score + margin = score: return num_rolls


backup lecture data
-------------------
mount mac: mount -t cifs //192.168.2.3/samba /mnt/mac/ -o username=samba
mirror web page: wget -mk -w 20 http://inst.cs.berkeley.edu/~cs61a/sp14/
dowload lecture screencasts: youtube-dl -citk --max-quality FORMAT 'https://www.youtube.com/view_play_list?p=-XXv-cvA_iC9x0nmh5OZyxljQU6pUWWk'

