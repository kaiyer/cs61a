1.2
"Pure functions are restricted in that they cannot have side effects or change behavior over time. "

HOF definition:
    A function that manipulates other functions as data is called a higher order function (HOF).
    For instance, a HOF can be a function that takes functions as arguments, returns a function
    as its value, or both.

difference defining functions with "def" vs. lambda expression:
  - "def" is a statement, evaluation has a side effect > generating function binding in current environment
  - lambda is an expression which won't usually change environemnt
    exception: lambda expression is assigned to a variable

pattern for designing recursive functions:
 - start with a base case, conditional statement for function inputs that are >>>simplest<<< 
   to process
 - base case is followed by one or more recursive calls. recursive calls have one goal:
   >>>simplifying the original problem<<<.
   recursive functions express computation by simplifying problems incremendially
     
leap of faith:
 - treating a recursive call as a function abstraction
 
mutual recursion:
 - a recursive procedure is divided by two functions calling each other  


tipps from lab for recursive functions:

  1. Always start with the base case. The base case handles the simplest argument 
     your function would have to handle. The answer is extremely simple, and often 
     follows from the definition of the problem.

  2. Make a recursive call with a slightly simpler argument. This is called the 
     "leap of faith" - your simpler argument should simplify the problem, and you 
     should assume that the recursive call for this simpler problem will just work. 
     As you do more problems, you'll get better at this step.

  3. Use the recursive call. Remember that the recursive call solves a simpler version 
     of the problem. Now ask yourself how you can use this result to solve the original 
     problem.

As a general rule of thumb, whenever you need to try multiple possibilities at the same time, 
you should consider using tree recursion.

lessons learned recursion (German)
..................................

- haeufig liegen base case bedingung um "0", eine summation/ berechnung bis zu einem spitzenwert
  wird versucht umzubauen zu einer differenzbildung die gegen "0" geht
- per rekursivem aufruf geaenderte parameter ( zb. def f(sum):  aufruf: f(sum-1) sind im frame
  der aufgerufenen funktion mit neuem geaenderten wert lokal vorhanden. von hier aus kann weiter
  runtergebrochen werden.
- summation: wenn nicht gegen "0" gearbeitet werden kann, muss trotzdem irgendwie ein abbruch
  wert (z.b. max_sum) in die rekusive-funktion propagiert werden. das macht man am besten mit
  einer  hilfsfunktion, die als zusaetzliches, sich nicht aenderndes argument den orignalwert
  max_sum mitfuehrt. siehe discussion/discussion3.py has_sum2() und sum_range() 
- bei sprachen mit lexical scoping kann die innere hilfsfunktion problemlos auf die argumente
  der parent-function zugreifen, siehe sum_range()   
- tree-recursion: wenn es um wahrheitspruefung (True/ False) geht, dann werden die verschiedenen
  suchzweige mit "OR" verknuepft. ein einziges "TRUE" in einer der rekursiven funktionsaufrufe
  wird bis nach oben propagiert und gibt als gesamtergebnis auch ein TRUE 

Data Abstraction
----------------
Data abstraction is a methodology that enables us to isolate how a compound data object
is used from the details of how it is constructed.


---------------------------------
A common convention is to use a single underscore character for the name in the for header 
if the name is unused in the suite:

>>> for _ in range(3):
        print('Go Bears!')

Go Bears!
Go Bears!
Go Bears!

This underscore is just another name in the environment as far as the interpreter is concerned, 
but has a conventional meaning among programmers that indicates the name will not appear in 
any expressions.
--------------------------------------

map/reduce
----------
- general computational patterns of mapping, filtering, and accumulation

TODO clearify "proof by induction"

running doc tests:
python3 -m doctest -v hog.py


noetherian induction:
a relation on values is well founded if there are no infinite decending chaines.

"If you start at some value and keep stepping to smaller values (according to the relation)
then you must always get to a minimal value after finite steps."

add:
basic recursion rules + example


swap:

score + margin = opponent score : return 0

harmful

opponent score + margin = score: return num_rolls


backup lecture data
-------------------
mount mac: mount -t cifs //192.168.2.3/samba /mnt/mac/ -o username=samba
mirror web page: wget -mk -w 20 http://inst.cs.berkeley.edu/~cs61a/sp14/
dowload lecture screencasts: youtube-dl -citk --max-quality FORMAT 'https://www.youtube.com/view_play_list?p=-XXv-cvA_iC9x0nmh5OZyxljQU6pUWWk'

